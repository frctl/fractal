#!/usr/bin/env node

const yargs = require('yargs');

if (yargs.argv.debug && !process.env.DEBUG) {
  process.env.DEBUG = 'frctl:*';
}

const {dirname} = require('path');
const findUp = require('find-up');
const pkgUp = require('pkg-up');
const importCwd = require('import-cwd');
const updateNotifier = require('update-notifier');
const {uniqBy, pick, assign, omit, keys} = require('lodash');
const loudRejection = require('loud-rejection');
const debug = require('debug')('frctl:cli');
const logger = require('@frctl/console');
const Cli = require('../src/cli');
const loadExtension = require('../src/load-extension');
const settings = require('../src/settings');
const cliPkg = require('../package.json');
const {log, error, warning} = logger;

loudRejection();
updateNotifier({pkg: cliPkg}).notify();

try {

  let Fractal;
  let configPath;
  let config = {};

  /*
   * look for a package.json to find the root of the project...
   */

  const pkgPath = pkgUp.sync();

  if (pkgPath) {

    /*
     * package.json found, load it and look for a config file.
     * Custom config file names can be specified using
     * the `fractal.config` property in the package.json
     */

    const pkg = require(pkgPath);
    const cwd = dirname(pkgPath);
    const pkgConfig = pkg.fractal || {};
    const configFiles = [].concat(pkgConfig.config || settings.config);

    process.chdir(cwd);

    debug(`package.json file found: %s`, pkgPath);
    debug(`set current working directory: %s`, cwd);

    configPath = findUp.sync(configFiles);

    if (configPath) {
      debug(`config file found: %s`, configPath);
      config = require(configPath);
      debug(`config file read OK`);
    } else {
      debug(`no config file found, looked for %s`, configFiles.join(', '));
    }

  } else {
    debug(`no package.json file found. Assuming global scope.`);
  }

  /*
   * Frist try and load a local Fractal instance,
   * falling back to the CLI dependency version if not found.
   */

  try {
    Fractal = importCwd('@frctl/fractal').Fractal;
  } catch(err) {
    debug(err);
    if (pkgPath) {
      debug(`no local Fractal instance available - using global instead (may result in version mismatch!)`);
       // TODO: detect and warn on version mismatch between app version and package.json dependency version?
    }
    Fractal = require('@frctl/fractal').Fractal;
  }

  /*
   * Build CLI config data.
   * The core CLI preset is pushed onto the front of the stack so that
   * user-defined commands can override the default set.
   */

  const cliConfig = Object.assign({}, config.cli || {}, {configPath});
  cliConfig.commands = cliConfig.commands || [];
  cliConfig.presets = cliConfig.presets || [];
  cliConfig.presets.unshift(require('@frctl/cli-preset-core'));

  const cli = new Cli(cliConfig);

  /*
   * Initialise Fractal instance.
   */

  const app = new Fractal(config.fractal);

  /*
   * Initialise extensions.
   *
   * Each key in the config is assumed to be an extension package name or path.
   * All core Fractal extensions can have the `@frctl/` namespace omitted and those
   * are checked for first, falling back to the un-namespaced package name if not found.
   *
   * Any extensions that are located are initialised with the fractal instance
   * and the relevant config options object.
   */

  for (const key of keys(omit(config, ['fractal', 'cli']))) {
    const extension = loadExtension(key, config[key], app);
    if (extension) {
      cli.config.push('commands', extension.commands || []);
      if (typeof extension.register === 'function') {
        extension.register(app);
      }
    } else {
      debug(`[!] A configuration key '${key}' was defined but no matching package could be loaded`);
    }
  }

  /*
   * Initialise CLI and yargs
   */



  let commandMatched = false;

  yargs.usage(settings.usage)
       .options(settings.options)
       .help()
       .demandCommand(1, 'You must specify a command.');

  for (const cmd of cli.getCommands()) {

    const handler = async function (argv) {
      debug(`running command '%s' with args %o`, cmd.name, argv);
      commandMatched = true;

      if (argv.help) {
        return yargs.showHelp();
      }

      try {
        const result = cmd.handler(argv, app, cli, logger);
        const output = await Promise.resolve(result);
        if (typeof output === 'string') {
          log(output);
        }
      } catch (err) {
        error(err);
      }
    };

    yargs.command(assign({handler}, pick(cmd, ['name','command','aliases','description','builder'])));

    debug(`registered command: %s`, cmd.name);
  }

  const argv = yargs.argv;

  if (!commandMatched) {
    throw new Error(`The command '${argv._.join(' ')}' was not recognised`);
  }

} catch(err) {
  error(err);
  process.exit(1);
}
